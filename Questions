
1. Какой самый эффективный способ конкатенации строк?

strings.Builder используется для эффективного добавления строк с использованием методов записи.

при вызове метода String() не происходит повторного выделения памяти и копирования данных
Метод Grow может использоваться для предварительного выделения памяти,
когда известен максимальный размер строки.

func concat2builder(x, y string) string {
    var builder strings.Builder
    builder.Grow(len(x) + len(y)) // эта строка выделяет память
    builder.WriteString(x)
    builder.WriteString(y)
    return builder.String()
}

2. Что такое интерфейсы, как они применяются в Go?

Интерфейс — это набор методов, представляющих стандартное поведение для различных типов данных.

С помощью интерфейсов можно организовывать разные группы методов, применяемых к разным объектам.
Таким образом, программа вместо фактических реализаций сможет опираться на более высокие абстракции (интерфейсы),
позволяя методам работать с различными объектами, реализующими один и тот же интерфейс.

3. Чем отличаются RWMutex от Mutex?

Разница в том, что операции чтения могут быть общими, и только операции записи требуют монопольного доступа.

Можно использовать Lock с участием Unlock, чтобы добиться блокировки записи,
и использовать RLock() с участием RUnlock, чтобы реализовать блокировки чтения

4. Чем отличаются буферизированные и не буферизированные каналы?

Канал — это объект связи, с помощью которого горутины обмениваются данными.

Буферизованный канал имеет очередь элементов.
Максимальный размер очереди определяется при создании канала с помощью аргумента емкости функции make.
Если канал заполнен, операция отправления блокирует свою go-подпрограмму до тех пор, пока другая go-подпрограмма не освободит место,
получив данные из канала. И наоборот, если канал пуст, операция получения блокирует горутину до того момента,
пока в канал не будет послано значение из другой горутинуы.

Небуферизованные каналы
Операция отправления в небуферизованный канал блокирует go-подпрограмму до тех пор, пока другая
go-подпрограмма не выполнит соответствующее получение из того же канала, после чего значение становится переданным,
и обе go-подпрограммы продолжаются. И наоборот, если первой сделана попытка выполнить операцию получения,
принимающая go-подпрограмма блокируется до тех пор,
пока другая go- подпрограмма не выполнит отправление значения в тот же канал.

5. Какой размер у структуры struct{}{}?

Пустая структура занимает 0 байт
Размер не пустой определяется содержимым

6. Есть ли в Go перегрузка методов или операторов?
нет

7. В какой последовательности будут выведены элементы map[int]int?
Пример:
m[0]=1
m[1]=124
m[2]=281

От запуска к запуску будут выводится в разной последовательности, потому что в го мапа неупорядоченная

8. В чем разница make и new?

Метод make () выделяет место в памяти только для типов slice, map и chan и инициализирует объект.
Его первый параметр - это тип, а второй параметр - параметр переменной длины, который возвращает сам тип.
возвращает инициализированное (не обнуленное) значение типа T(не *T)
Для срезов, карт и каналов, make инициализирует внутреннюю структуру данных и подготавливает значение для использования.

Метод new () выделяет место в памяти.
Его первым параметром является тип, а затем он возвращает указатель на область памяти этого типа.


9. Сколько существует способов задать переменную типа slice или map?

-make
-[]slice{} //пустой слайс, либо инициализированный
-slice[1:3] //срез массива либо другого слайса

10. Что выведет данная программа и почему
func update(p *int) {
    b := 2
    p = &b
    }
    func main() {
    var (
    a = 1
    p = &a
    )
    fmt.Println(*p)
    update(p)
    fmt.Println(*p)
    }
//1
//1
потому что в функции update мы меняем значение локальной p

11. Что выведет данная программа и почему?
func main() {
    wg := sync.WaitGroup{}
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(wg sync.WaitGroup, i int) {
            fmt.Println(i)
            wg.Done()
        }(wg, i)
        }
    wg.Wait()
    fmt.Println("exit")
}
//1 2 3 4 5 deadlock
потому что мы передаем значение wg sync.WaitGroup, а не указатель,
соответственно done выполняется для локальной копии

12. Что выведет данная программа и почему?
func main() {
    n := 0
    if true {
        n := 1
        n++
    }
    fmt.Println(n)
}
//0
потому что n созданная в if находится в обасти видимости только в нем

13. Что выведет данная программа и почему?
func someAction(v []int8, b int8) {
    v[0] = 100
    v = append(v, b)
}
func main() {
    var a = []int8{1, 2, 3, 4, 5}
    someAction(a, 6)
    fmt.Println(a)
}
//100 2 3 4 5
изменения в срезе сохраняются потому что передаются по ссылке, а не по значению
функция append выделяет новую память под срез, следовательно это будет локальное изменение в функции

14. Что выведет данная программа и почему?
func main() {
    slice := []string{"a", "a"}
    func(slice []string) {
        slice = append(slice, "a")
        slice[0] = "b"
        slice[1] = "b"
        fmt.Print(slice)
    }(slice)
    fmt.Print(slice)
}
//b b a
//a a
в анонмной функции создается новый срез, который не влияет на исходный
